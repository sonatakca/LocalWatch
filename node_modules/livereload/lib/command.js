// Generated by CoffeeScript 2.7.0
(function() {
  var createServerFromArgs, livereload, parseArgsAndCreateServer, pjson, resolve, runner;

  pjson = require('../package.json');

  livereload = require('./livereload');

  resolve = require('path').resolve;

  runner = function() {
    var path, res, server;
    res = parseArgsAndCreateServer(true);
    server = res.server;
    path = res.path;
    console.log(`Starting LiveReload v${pjson.version} for ${path} on ${server.config.host}:${server.config.port}.`);
    server.on('error', function(err) {
      if (err.code === "EADDRINUSE") {
        console.log("The port LiveReload wants to use is used by something else.");
      } else {
        throw err;
      }
      return process.exit(1);
    });
    return server.watch(path);
  };

  // Parse the arguments and create the server.
  // shouldListen option exists so we can start the server under CLI, but not when
  // we use this from the entrypoint for tests
  parseArgsAndCreateServer = function(shouldListen = true) {
    var args, corp, cors, debug, exclusions, extraExts, exts, filesToReload, host, options, opts, originalPath, path, port, server, usePolling, wait;
    opts = require('opts');
    args = [
      {
        name: 'path',
        required: false
      }
    ];
    options = [
      {
        short: "v",
        long: "version",
        description: "Show the version",
        required: false,
        callback: function() {
          console.log(pjson.version);
          return process.exit(1);
        }
      },
      {
        short: "p",
        long: "port",
        description: "Specify the port the server should listen on.",
        value: true,
        required: false
      },
      {
        short: "b",
        long: "bind",
        description: "Specify the host the server should listen on.",
        value: true,
        required: false
      },
      {
        short: "x",
        long: "exclusions",
        description: "Exclude files from being watched by specifying an array of regular expressions. Will be appended to default value which is [/\.git\//, /\.svn\//, /\.hg\//]",
        required: false,
        value: true
      },
      {
        short: "d",
        long: "debug",
        description: "See helpful debugging information",
        required: false
      },
      {
        short: "e",
        long: "exts",
        description: "A comma-separated list of extensions that should trigger a reload when changed. Replaces default extensions",
        required: false,
        value: true
      },
      {
        short: "ee",
        long: "extraExts",
        description: "A comma-separated list of extensions that should trigger a reload when changed, in addition to the defaults (html, css, js, png, gif, jpg, php, php5, py, rb, erb, coffee). If used with --exts, this overrides --exts.",
        required: false,
        value: true
      },
      {
        short: "f",
        long: "filesToReload",
        description: "A comma-separated list of filenames that should trigger a reload when changed.",
        required: false,
        value: true
      },
      {
        short: "u",
        long: "usepolling",
        description: "Poll for file system changes. Set this to true to successfully watch files over a network.",
        required: false
      },
      {
        short: "w",
        long: "wait",
        description: "Delay message of file system changes to browser by `delay` milliseconds",
        required: false,
        value: true
      },
      {
        short: "op",
        long: "originalpath",
        description: "Set a URL you use for development, e.g 'http://domain.com', then LiveReload will proxy this url to local path.",
        required: false,
        value: true
      },
      {
        short: "cp",
        long: "corp",
        description: "Enable CORP Header with cross-origin",
        required: false
      },
      {
        short: "cs",
        long: "cors",
        description: "Enable CORS Header for all or specific origins",
        required: false,
        value: true
      }
    ];
    opts.parse(options.reverse(), args, true);
    path = (opts.arg('path') || '.').split(/\s*,\s*/).map(function(x) {
      return resolve(x);
    });
    debug = opts.get('debug') || false;
    port = parseInt(opts.get('port')) || 35729;
    host = opts.get('bind') || 'localhost';
    exclusions = opts.get('exclusions') ? opts.get('exclusions').split(',').map(function(s) {
      return new RegExp(s);
    }) : [];
    exts = opts.get('exts') ? opts.get('exts').split(',').map(function(ext) {
      return ext.trim();
    }) : [];
    extraExts = opts.get('extraExts') ? opts.get('extraExts').split(',').map(function(ext) {
      return ext.trim();
    }) : [];
    filesToReload = opts.get('filesToReload') ? opts.get('filesToReload').split(',').map(function(file) {
      return file.trim();
    }) : [];
    usePolling = opts.get('usepolling') || false;
    wait = parseInt(opts.get('wait')) || 0;
    originalPath = opts.get('originalpath') || '';
    cors = opts.get('cors') || false;
    corp = opts.get('corp') || false;
    server = livereload.createServer({
      port: port,
      host: host,
      debug: debug,
      exclusions: exclusions,
      exts: exts,
      extraExts: extraExts,
      usePolling: usePolling,
      filesToReload: filesToReload,
      delay: wait,
      originalPath: originalPath,
      cors: cors,
      corp: corp,
      noListen: !shouldListen
    });
    return {
      server: server,
      path: path
    };
  };

  // This is the entrypoint that tests use to verify our option parsing.
  // It doesn't start the server.
  // The opts library directly parses process.argv. That means
  // when we run tests with Mocha it gets the Mocha args, not our args.
  // So this is hacky indirection that lets us send our own args
  // from the tests and still run them through the same parsing function
  // the CLI uses.
  createServerFromArgs = function(testArgv) {
    var originalArgv, result;
    // Save original process.argv and parse with test arguments
    originalArgv = process.argv;
    // replace the args with our test args
    process.argv = ['node', 'test'].concat(testArgv);
    // Reset opts internal state by requiring a fresh instance
    delete require.cache[require.resolve('opts')];
    try {
      result = parseArgsAndCreateServer(false); // false = don't listen, for testing
      return result;
    } finally {
      // Always restore original process.argv
      process.argv = originalArgv;
    }
  };

  module.exports = {
    run: runner,
    createServerFromArgs: createServerFromArgs
  };

}).call(this);
