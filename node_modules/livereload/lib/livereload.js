// Generated by CoffeeScript 2.7.0
(function() {
  var EventEmitter, Server, chokidar, defaultExclusions, defaultExts, defaultHost, defaultPort, fs, http, https, path, protocol_version, url, ws;

  fs = require('fs');

  path = require('path');

  ws = require('ws');

  http = require('http');

  https = require('https');

  url = require('url');

  chokidar = require('chokidar');

  EventEmitter = require('events');

  protocol_version = '7';

  defaultPort = 35729;

  defaultHost = 'localhost';

  defaultExts = ['html', 'css', 'js', 'png', 'gif', 'jpg', 'php', 'php5', 'py', 'rb', 'erb', 'coffee'];

  defaultExclusions = [/\.git\//, /\.svn\//, /\.hg\//];

  // Server accepts a Configuration object to configure the server.

  // `version`: The protocol version to use.
  // `port`: the LiveReload listen port
  // `host`: the LiveReload listen host
  // `corp`: enable Cross-Origin Resource Policy support.
  // `cors`: Enable CORS (all or specified hostname)
  // `exts`: the extensions to watch. An array of extensions.
  // `extraExts`: extensions in addition to the default extensions
  // `exclusions`: array of regex patterns to exclude. Default is [/\.git\//, /\.svn\//, /\.hg\//]
  // `filesToReload`: array of files that, when changed, should force the browser to reload
  // `applyCSSLive`: should the css apply live? Default is true
  // `originalPath`: the original path. Useful for proxy
  // `usePolling`: Should we use polling instead of a file watcher? defaults to false.
  // `delay`: seconds to wait
  // `debug`: display debug mesages to stdout. Default is false

  Server = class Server extends EventEmitter {
    constructor(config1) {
      var base, base1, base10, base2, base3, base4, base5, base6, base7, base8, base9;
      super();
      this.config = config1;
      if (this.config == null) {
        this.config = {};
      }
      if ((base = this.config).version == null) {
        base.version = protocol_version;
      }
      if ((base1 = this.config).port == null) {
        base1.port = defaultPort;
      }
      if ((base2 = this.config).host == null) {
        base2.host = defaultHost;
      }
      if ((base3 = this.config).exts == null) {
        base3.exts = [];
      }
      if ((base4 = this.config).extraExts == null) {
        base4.extraExts = [];
      }
      if ((base5 = this.config).exclusions == null) {
        base5.exclusions = [];
      }
      if ((base6 = this.config).filesToReload == null) {
        base6.filesToReload = [];
      }
      if (this.config.exts.length === 0) {
        this.config.exts = defaultExts;
      }
      if (this.config.extraExts.length > 0) {
        this.config.exts = this.config.extraExts.concat(defaultExts);
      }
      this.config.exclusions = this.config.exclusions.concat(defaultExclusions);
      if ((base7 = this.config).applyCSSLive == null) {
        base7.applyCSSLive = true;
      }
      if ((base8 = this.config).originalPath == null) {
        base8.originalPath = '';
      }
      if ((base9 = this.config).overrideURL == null) {
        base9.overrideURL = '';
      }
      if ((base10 = this.config).usePolling == null) {
        base10.usePolling = false;
      }
    }

    listen(callback) {
      this.debug("LiveReload is waiting for a browser to connect...");
      this.debug(`Protocol version: ${this.config.version}
Exclusions: ${this.config.exclusions}
Extensions: ${this.config.exts}
Polling: ${this.config.usePolling}
`);
      if (this.config.server) {
        this.config.server.listen(this.config.port, this.config.host);
        this.server = new ws.Server({
          server: this.config.server
        });
      } else {
        this.server = new ws.Server({
          port: this.config.port,
          host: this.config.host
        });
      }
      this.server.on('connection', this.onConnection.bind(this));
      this.server.on('close', this.onClose.bind(this));
      this.server.on('error', this.onError.bind(this));
      if (callback) {
        return this.server.once('listening', callback);
      }
    }

    // Bubble up the connection error to the parent process
    // Subscribe with server.on "error"
    onError(err) {
      this.debug(`Error ${err}`);
      return this.emit("error", err);
    }

    onConnection(socket) {
      this.debug("Browser connected.");
      // Client sends various messages under the key 'command'

      // 'hello': the handshake. Must reply with 'hello'
      // 'info' : info about the client script and any plugins it has enabled

      socket.on('message', (message) => {
        var data, request;
        this.debug(`Client message: ${message}`);
        request = JSON.parse(message);
        if (request.command === "hello") {
          this.debug("Client requested handshake...");
          this.debug(`Handshaking with client using protocol ${this.config.version}...`);
          data = JSON.stringify({
            command: 'hello',
            protocols: ['http://livereload.com/protocols/official-7', 'http://livereload.com/protocols/official-8', 'http://livereload.com/protocols/official-9', 'http://livereload.com/protocols/2.x-origin-version-negotiation', 'http://livereload.com/protocols/2.x-remote-control'],
            serverName: 'node-livereload'
          });
          socket.send(data);
        }
        // info messages are messages about the features the client server has, like
        // plugins. We don't support these but in debug mode we should at least
        // acknowledge them in the console for debugging purposes
        if (request.command === "info") {
          return this.debug("Server received client data. Not sending response.");
        }
      });
      // handle error events from socket
      socket.on('error', (err) => {
        return this.debug(`Error in client socket: ${err}`);
      });
      return socket.on('close', (message) => {
        return this.debug("Client closed connection");
      });
    }

    onClose(socket) {
      return this.debug("Socket closed.");
    }

    watch(paths) {
      this.debug(`Watching ${paths}...`);
      return this.watcher = chokidar.watch(paths, {
        ignoreInitial: true,
        ignored: this.config.exclusions,
        usePolling: this.config.usePolling
      }).on('add', this.filterRefresh.bind(this)).on('change', this.filterRefresh.bind(this)).on('unlink', this.filterRefresh.bind(this));
    }

    // Determine whether or not the file should trigger a reload.
    // Only reload if the changed file is in the list of extensions,
    // or if it's in the list of explicit file names.
    filterRefresh(filepath) {
      var delayedRefresh, fileext, filename, refresh;
      refresh = false;
      this.debug(`Saw change to ${filepath}`);
      // get just the extension         without the .
      fileext = path.extname(filepath).substring(1);
      // get the filename from the path
      filename = path.basename(filepath);
      // check if file extension is supposed to be watched
      if (this.config.exts.indexOf(fileext) !== -1) {
        refresh = true;
      }
      // check to see if the file is explicitly listed
      if (this.config.filesToReload.indexOf(filename) !== -1) {
        refresh = true;
      }
      if (refresh) {
        if (this.config.delay) {
          return delayedRefresh = setTimeout(() => {
            clearTimeout(delayedRefresh);
            return this.refresh(filepath);
          }, this.config.delay);
        } else {
          return this.refresh(filepath);
        }
      }
    }

    refresh(filepath) {
      var data;
      this.debug(`Reloading: ${filepath}`);
      data = JSON.stringify({
        command: 'reload',
        path: filepath,
        liveCSS: this.config.applyCSSLive,
        liveImg: this.config.applyImgLive,
        originalPath: this.config.originalPath,
        overrideURL: this.config.overrideURL
      });
      return this.sendAllClients(data);
    }

    alert(message) {
      var data;
      this.debug(`Alert: ${message}`);
      data = JSON.stringify({
        command: 'alert',
        message: message
      });
      return this.sendAllClients(data);
    }

    sendAllClients(data) {
      return this.server.clients.forEach((socket) => {
        this.debug(`broadcasting to all clients: ${data}`);
        return socket.send(data, (error) => {
          if (error) {
            return this.debug(error);
          }
        });
      });
    }

    debug(str) {
      if (this.config.debug) {
        return console.log(`${str}\n`);
      }
    }

    close() {
      if (this.watcher) {
        this.watcher.close();
      }
      // ensure ws server is closed
      this.server._server.close();
      return this.server.close();
    }

  };

  exports.createServer = function(config = {}, callback) {
    var app, headers, key, requestHandler, server, value;
    headers = {
      'Content-Type': 'application/javascript'
    };
    if (config != null ? config.corp : void 0) {
      headers['Cross-Origin-Resource-Policy'] = 'cross-origin';
    }
    if (config != null ? config.cors : void 0) {
      headers['Access-Control-Allow-Origin'] = typeof config.cors === 'string' ? config.cors : '*';
      headers['Access-Control-Allow-Methods'] = 'OPTIONS, HEAD, GET, POST';
    }
    requestHandler = function(req, res) {
      if (req.url.startsWith('/livereload.js')) {
        res.writeHead(200, headers);
        return res.end(fs.readFileSync(require.resolve('livereload-js')));
      }
    };
    if (config.https == null) {
      app = http.createServer(requestHandler);
    } else {
      app = https.createServer(config.https, requestHandler);
    }
    if (config.debug) {
      console.log("Headers:");
      for (key in headers) {
        value = headers[key];
        console.log(`${key}: ${value}`);
      }
    }
    if (config.server == null) {
      config.server = app;
    }
    server = new Server(config);
    if (!config.noListen) {
      server.listen(callback);
    }
    return server;
  };

}).call(this);
